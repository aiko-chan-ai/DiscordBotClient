<!DOCTYPE html>
<html>

<head>
        <meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=3.0" name="viewport" />

        <!-- section:seometa -->
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="Discord" />
        <meta property="og:title" content="Discord - A New Way to Chat with Friends & Communities" />
        <meta property="og:description"
                content="Discord is the easiest way to communicate over voice, video, and text.  Chat, hang out, and stay close with your friends and communities." />
        <meta property="og:image" content="https://discord.com/assets/652f40427e1f5186ad54836074898279.png" />
        <link rel="icon" href="/assets/ec2c34cadd4b5f4594415127380a85e6.ico">
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@discord" />
        <meta name="twitter:creator" content="@discord" />
        <!-- endsection -->
        <script>
                var client;
                var tryFetchMemberList = false;
                var lasestGuildIdVoiceConnect = 0;
                window.__OVERLAY__ = /overlay/.test(location.pathname);
                window.__BILLING_STANDALONE__ = /^\/billing/.test(location.pathname);
                window.GLOBAL_ENV = {
                        API_ENDPOINT: '//' + window.location.host + '/d/api',
                        API_VERSION: 9,
                        GATEWAY_ENDPOINT: 'wss://gateway.discord.gg',
                        RELEASE_CHANNEL: 'stable',
                        HTML_TIMESTAMP: Date.now(),
                        ALGOLIA_KEY: 'aca0d7082e4e63af5ba5917d5e96bed0',
                        WEBAPP_ENDPOINT: "//" + window.location.host,
                        CDN_HOST: 'cdn.discordapp.com',
                        ASSET_ENDPOINT: "//" + window.location.host,
                        MEDIA_PROXY_ENDPOINT: '//media.discordapp.net',
                        WIDGET_ENDPOINT: '//discord.com/widget',
                        INVITE_HOST: 'discord.gg',
                        GUILD_TEMPLATE_HOST: 'discord.new',
                        GIFT_CODE_HOST: 'discord.gift',
                        MARKETING_ENDPOINT: '//discord.com',
                        BRAINTREE_KEY: 'production_5st77rrc_49pp2rp4phym7387',
                        STRIPE_KEY: 'pk_live_CUQtlpQUF0vufWpnpUmQvcdi',
                        NETWORKING_ENDPOINT: '//router.discordapp.net',
                        RTC_LATENCY_ENDPOINT: '//latency.discord.media/rtc',
                        ACTIVITY_APPLICATION_HOST: 'discordsays.com',
                        PROJECT_ENV: 'production',
                        REMOTE_AUTH_ENDPOINT: '//remote-auth-gateway.discord.gg',
                        SENTRY_TAGS: { "buildId": "7956ae0a7fef17564b5e718757ad1a38d2322063", "buildType": "normal" },
                        MIGRATION_SOURCE_ORIGIN: 'https://discord.com',
                        MIGRATION_DESTINATION_ORIGIN: window.location.protocol + "//" + window.location.host,
                };
                Object.defineProperty(window, "localStorage_", {
                        value: window.localStorage
                });
                const localStorage = window.localStorage;
                var getModule, findModule, readyData, emitReady, getStatus, membersOnline, membersOffline, funcUpdate, guildIdCurrent, channelIdCurrent;
                var loadFullGuild = 0;
                var allGuild = 0;
                var intentBot = localStorage_.getItem("intents");
                var lastTimeDelay = 0;
                var eDispatch;
                const IntentFlags = {
                        GUILDS: 1 << 0,
                        GUILD_MEMBERS: 1 << 1,
                        GUILD_BANS: 1 << 2,
                        GUILD_EMOJIS_AND_STICKERS: 1 << 3,
                        GUILD_INTEGRATIONS: 1 << 4,
                        GUILD_WEBHOOKS: 1 << 5,
                        GUILD_INVITES: 1 << 6,
                        GUILD_VOICE_STATES: 1 << 7,
                        GUILD_PRESENCES: 1 << 8,
                        GUILD_MESSAGES: 1 << 9,
                        GUILD_MESSAGE_REACTIONS: 1 << 10,
                        GUILD_MESSAGE_TYPING: 1 << 11,
                        DIRECT_MESSAGES: 1 << 12,
                        DIRECT_MESSAGE_REACTIONS: 1 << 13,
                        DIRECT_MESSAGE_TYPING: 1 << 14,
                        MESSAGE_CONTENT: 1 << 15,
                        GUILD_SCHEDULED_EVENTS: 1 << 16,
                        // https://discord.com/developers/docs/topics/gateway#list-of-intents
                        AUTO_MODERATION_CONFIGURATION: 1 << 20,
                        AUTO_MODERATION_EXECUTION: 1 << 21,
                };
                const getIntents = (...removeIntents) => Object.values(IntentFlags).reduce((a, b) => a + b) - (removeIntents.flat(2).map(name => IntentFlags[name] || 0).reduce((a, b) => a + b, 0) || 0);
                var callSetIntents = () => {
                        const privilegedIntents = [];
                        alert("Login with bot requires privileged intent `MESSAGE_CONTENT`\n\nMake sure you have enabled this intent in the bot settings.");
                        if (!confirm('[Optional] Do you want to use the `GUILD_PRESENCES` intent?')) {
                                privilegedIntents.push('GUILD_PRESENCES');
                        }
                        if (!confirm('[Optional] Do you want to use the `GUILD_MEMBERS` intent?')) {
                                privilegedIntents.push('GUILD_MEMBERS');
                        }
                        intentBot = getIntents(...privilegedIntents);
                        localStorage_.setItem('intents', intentBot);
                }
        </script>
</head>

<body>
        <div id="app-mount"></div>
        <script src="/assets/9af08cab5ec8da0028ac.js"></script>
        <script src="/assets/12ce378cc6190128aac5.js"></script>
        <script src="/assets/180d44fd394555f21790.js"></script>
        <script src="/assets/02be0d5b4681a76d9def.js"></script>
        <script>
                window.onload = function () {
                        getModule = (n, f = true) => { // 'f' is whether to return the first module found if it goes by display name
                                const cache = () => {
                                        let webp = window.webpackChunkdiscord_app.push([
                                                [Symbol()], {},
                                                _ => _.c
                                        ]);
                                        window.webpackChunkdiscord_app.pop();
                                        return webp;
                                };
                                let findAllModules = (filter = (m) => m) => {
                                        let modules = [];
                                        for (let item in cache()) {
                                                if (Object.hasOwnProperty.call(cache(), item)) {
                                                        let element = cache()[item].exports;
                                                        if (!element) {
                                                                continue
                                                        }
                                                        if (filter(element)) {
                                                                modules.push(element)
                                                        }
                                                }
                                        }
                                        return modules
                                };
                                let x = false;
                                let mod;
                                window.webpackChunkdiscord_app.push([
                                        [Math.random()], {}, (e) => {
                                                mod = mod || Object.values(e.c).find(m => m?.exports?.Z?.[n]);
                                        }
                                ]);
                                window.webpackChunkdiscord_app.pop();
                                if (typeof mod === "undefined") {
                                        window.webpackChunkdiscord_app.push([
                                                [Math.random()], {}, (e) => {
                                                        mod = mod || Object.values(e.c).find(m => m?.exports?.[n]);
                                                }
                                        ]);
                                        window.webpackChunkdiscord_app.pop();
                                }
                                if (typeof mod === "undefined") {
                                        x = true;
                                        if (f == true) {
                                                mod = mod || (typeof findAllModules(m => m?.Z?.displayName === n) !== "undefined") ? findAllModules(m => m?.Z?.displayName === n)?.[0] : findAllModules(m => m?.displayName === n)?.[0];
                                        } else {
                                                mod = mod || (typeof findAllModules(m => m?.Z?.displayName === n) !== "undefined") ? findAllModules(m => m?.Z?.displayName === n) : findAllModules(m => m?.displayName === n);
                                        }
                                }
                                if (x) {
                                        return (typeof mod?.Z !== "undefined") ? mod?.Z : mod;
                                }
                                else if (x == false) {
                                        return (typeof mod?.exports?.Z !== "undefined") ? mod?.exports?.Z : mod?.exports;
                                }
                                return undefined;
                        }
                        findModule = (n, b) => {
                                (d = typeof b === "undefined" ? true : b,
                                        n = n.toLowerCase(),
                                        m = []);
                                webpackChunkdiscord_app.push([
                                        [Math.random()], {},
                                        (e) => {
                                                m.push(...Object.values(e.c).filter(m => m?.exports && ((m?.exports?.Z && Object.keys(m.exports.Z).some(key => key.toLowerCase().includes(n))) || (m.exports?.Z?.prototype && Object.keys(m.exports.Z.prototype).some(key => key.toLowerCase().includes(n))) || Object.keys(m.exports).some(key => key.toLowerCase().includes(n)))))
                                        }
                                ]);
                                webpackChunkdiscord_app.pop();
                                if (d) {
                                        m.forEach(f => m.push(typeof f?.exports?.Z === "undefined" ? f?.exports : f?.exports?.Z));
                                        for (var i = 0; i < m.length; i++) {
                                                m.forEach((f, i) => typeof f?.id === "undefined" ? m = m : m.splice(i, 1));
                                        }
                                        return [...m].filter(m => m?.Window?.name !== "Window");
                                } else {
                                        return [...m].filter(m => m?.Window?.name !== "Window");
                                };
                        }
                        loadClient();
                        client = new Client();
                };
                i = setInterval(() => {
                        let buttonLogin = document.getElementsByClassName("marginBottom8-emkd0_ button-1cRKG6 button-f2h6uQ lookFilled-yCfaCM colorBrand-I6CyqQ sizeLarge-3mScP9 fullWidth-fJIsjq grow-2sR_-F")[0];
                        if (buttonLogin) {
                                buttonLogin.addEventListener("click", () => {
                                        const input = document.getElementsByClassName("inputDefault-3FGxgL input-2g-os5")[0];
                                        getModule('loginToken').loginToken(input.value);
                                });

                                const email = document.getElementsByClassName("marginBottom20-315RVT")[0];
                                email.parentElement.removeChild(email);

                                const input_ = document.getElementsByClassName("label-2bTGzo title-3hptVQ defaultColor-2cKwKo defaultMarginlabel-1h4HPn")[0]

                                input_.innerHTML = "Token";
                                input_.id = "token";

                                const QR = document.getElementsByClassName("transitionGroup-bPT0qU qrLogin-1ejtpI")[0];
                                QR.parentElement.removeChild(QR);

                                const dot = document.getElementsByClassName("verticalSeparator-2r9gHa")[0];
                                dot.parentElement.removeChild(dot);
                                clearInterval(i);

                                if (!intentBot) {
                                        callSetIntents();
                                } else if (confirm(`Do you want to set new intents?\nOld intents: ${intentBot}`)) {
                                        callSetIntents();
                                }
                        }
                }, 250);
        </script>
        <script>
                // Embed script
                // MessageEmbed v13

                const Colors = {
                        DEFAULT: 0x000000,
                        WHITE: 0xffffff,
                        AQUA: 0x1abc9c,
                        GREEN: 0x57f287,
                        BLUE: 0x3498db,
                        YELLOW: 0xfee75c,
                        PURPLE: 0x9b59b6,
                        LUMINOUS_VIVID_PINK: 0xe91e63,
                        FUCHSIA: 0xeb459e,
                        GOLD: 0xf1c40f,
                        ORANGE: 0xe67e22,
                        RED: 0xed4245,
                        GREY: 0x95a5a6,
                        NAVY: 0x34495e,
                        DARK_AQUA: 0x11806a,
                        DARK_GREEN: 0x1f8b4c,
                        DARK_BLUE: 0x206694,
                        DARK_PURPLE: 0x71368a,
                        DARK_VIVID_PINK: 0xad1457,
                        DARK_GOLD: 0xc27c0e,
                        DARK_ORANGE: 0xa84300,
                        DARK_RED: 0x992d22,
                        DARK_GREY: 0x979c9f,
                        DARKER_GREY: 0x7f8c8d,
                        LIGHT_GREY: 0xbcc0c0,
                        DARK_NAVY: 0x2c3e50,
                        BLURPLE: 0x5865f2,
                        GREYPLE: 0x99aab5,
                        DARK_BUT_NOT_BLACK: 0x2c2f33,
                        NOT_QUITE_BLACK: 0x23272a,
                }

                function cloneObject(obj) {
                        return Object.assign(Object.create(obj), obj);
                }

                function resolveColor(color) {
                        if (typeof color === 'string') {
                                if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));
                                if (color === 'DEFAULT') return 0;
                                color = Colors[color] ?? parseInt(color.replace('#', ''), 16);
                        } else if (Array.isArray(color)) {
                                color = (color[0] << 16) + (color[1] << 8) + color[2];
                        }

                        if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');
                        else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');

                        return color;
                }

                class MessageEmbed {
                        constructor(data = {}, skipValidation = false) {
                                this.setup(data, skipValidation);
                        }

                        setup(data, skipValidation) {
                                this.type = data.type ?? 'rich';

                                this.title = data.title ?? null;

                                this.description = data.description ?? null;

                                this.url = data.url ?? null;

                                this.color = 'color' in data ? resolveColor(data.color) : null;

                                this.timestamp = 'timestamp' in data ? new Date(data.timestamp).getTime() : null;

                                this.fields = [];
                                if (data.fields) {
                                        this.fields = skipValidation ? data.fields.map(cloneObject) : this.constructor.normalizeFields(data.fields);
                                }

                                this.thumbnail = data.thumbnail
                                        ? {
                                                url: data.thumbnail.url,
                                                proxyURL: data.thumbnail.proxyURL ?? data.thumbnail.proxy_url,
                                                height: data.thumbnail.height,
                                                width: data.thumbnail.width,
                                        }
                                        : null;

                                this.image = data.image
                                        ? {
                                                url: data.image.url,
                                                proxyURL: data.image.proxyURL ?? data.image.proxy_url,
                                                height: data.image.height,
                                                width: data.image.width,
                                        }
                                        : null;

                                this.video = data.video
                                        ? {
                                                url: data.video.url,
                                                proxyURL: data.video.proxyURL ?? data.video.proxy_url,
                                                height: data.video.height,
                                                width: data.video.width,
                                        }
                                        : null;

                                this.author = data.author
                                        ? {
                                                name: data.author.name,
                                                url: data.author.url,
                                                iconURL: data.author.iconURL ?? data.author.icon_url,
                                                proxyIconURL: data.author.proxyIconURL ?? data.author.proxy_icon_url,
                                        }
                                        : null;

                                this.provider = data.provider
                                        ? {
                                                name: data.provider.name,
                                                url: data.provider.url,
                                        }
                                        : null;

                                this.footer = data.footer
                                        ? {
                                                text: data.footer.text,
                                                iconURL: data.footer.iconURL ?? data.footer.icon_url,
                                                proxyIconURL: data.footer.proxyIconURL ?? data.footer.proxy_icon_url,
                                        }
                                        : null;
                        }

                        get createdAt() {
                                return this.timestamp ? new Date(this.timestamp) : null;
                        }

                        get hexColor() {
                                return this.color ? `#${this.color.toString(16).padStart(6, '0')}` : null;
                        }

                        get length() {
                                return (
                                        (this.title?.length ?? 0) +
                                        (this.description?.length ?? 0) +
                                        (this.fields.length >= 1
                                                ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)
                                                : 0) +
                                        (this.footer?.text.length ?? 0) +
                                        (this.author?.name.length ?? 0)
                                );
                        }

                        equals(embed) {
                                return (
                                        this.type === embed.type &&
                                        this.author?.name === embed.author?.name &&
                                        this.author?.url === embed.author?.url &&
                                        this.author?.iconURL === (embed.author?.iconURL ?? embed.author?.icon_url) &&
                                        this.color === embed.color &&
                                        this.title === embed.title &&
                                        this.description === embed.description &&
                                        this.url === embed.url &&
                                        this.timestamp === embed.timestamp &&
                                        this.fields.length === embed.fields.length &&
                                        this.fields.every((field, i) => this._fieldEquals(field, embed.fields[i])) &&
                                        this.footer?.text === embed.footer?.text &&
                                        this.footer?.iconURL === (embed.footer?.iconURL ?? embed.footer?.icon_url) &&
                                        this.image?.url === embed.image?.url &&
                                        this.thumbnail?.url === embed.thumbnail?.url &&
                                        this.video?.url === embed.video?.url &&
                                        this.provider?.name === embed.provider?.name &&
                                        this.provider?.url === embed.provider?.url
                                );
                        }

                        _fieldEquals(field, other) {
                                return field.name === other.name && field.value === other.value && field.inline === other.inline;
                        }

                        addField(name, value, inline) {
                                return this.addFields({ name, value, inline });
                        }

                        addFields(...fields) {
                                this.fields.push(...this.constructor.normalizeFields(fields));
                                return this;
                        }

                        spliceFields(index, deleteCount, ...fields) {
                                this.fields.splice(index, deleteCount, ...this.constructor.normalizeFields(...fields));
                                return this;
                        }

                        setFields(...fields) {
                                this.spliceFields(0, this.fields.length, fields);
                                return this;
                        }

                        setAuthor(options, deprecatedIconURL, deprecatedURL) {
                                if (options === null) {
                                        this.author = {};
                                        return this;
                                }

                                if (typeof options === 'string') {
                                        options = { name: options, url: deprecatedURL, iconURL: deprecatedIconURL };
                                }

                                const { name, url, iconURL } = options;
                                this.author = { name, url, iconURL };
                                return this;
                        }

                        setColor(color) {
                                this.color = resolveColor(color);
                                return this;
                        }

                        setDescription(description) {
                                this.description = description;
                                return this;
                        }

                        setFooter(options, deprecatedIconURL) {
                                if (options === null) {
                                        this.footer = undefined;
                                        return this;
                                }

                                if (typeof options === 'string') {
                                        options = { text: options, iconURL: deprecatedIconURL };
                                }

                                const { text, iconURL } = options;
                                this.footer = { text, iconURL };
                                return this;
                        }

                        setImage(url) {
                                this.image = { url };
                                return this;
                        }

                        setThumbnail(url) {
                                this.thumbnail = { url };
                                return this;
                        }

                        setTimestamp(timestamp = Date.now()) {
                                if (timestamp instanceof Date) timestamp = timestamp.getTime();
                                this.timestamp = timestamp;
                                return this;
                        }

                        setTitle(title) {
                                this.title = title;
                                return this;
                        }

                        setURL(url) {
                                this.url = url;
                                return this;
                        }

                        toJSON() {
                                return {
                                        title: this.title,
                                        type: 'rich',
                                        description: this.description,
                                        url: this.url,
                                        timestamp: this.timestamp && new Date(this.timestamp),
                                        color: this.color,
                                        fields: this.fields,
                                        thumbnail: this.thumbnail,
                                        image: this.image,
                                        author: this.author && {
                                                name: this.author.name,
                                                url: this.author.url,
                                                icon_url: this.author.iconURL,
                                        },
                                        footer: this.footer && {
                                                text: this.footer.text,
                                                icon_url: this.footer.iconURL,
                                        },
                                };
                        }

                        static normalizeField(name, value, inline = false) {
                                return {
                                        name,
                                        value,
                                        inline,
                                };
                        }

                        static normalizeFields(...fields) {
                                return fields
                                        .flat(2)
                                        .map(field =>
                                                this.normalizeField(field.name, field.value, typeof field.inline === 'boolean' ? field.inline : false),
                                        );
                        }
                }
        </script>
        <script>
                // Message Button and Menu
                function createEnum(keys) {
                        const obj = {};
                        for (const [index, key] of keys.entries()) {
                                if (key === null) continue;
                                obj[key] = index;
                                obj[index] = key;
                        }
                        return obj;
                }


                const MessageComponentTypes = createEnum([
                        null,
                        'ACTION_ROW',
                        'BUTTON',
                        'STRING_SELECT',
                        'TEXT_INPUT',
                        'USER_SELECT',
                        'ROLE_SELECT',
                        'MENTIONABLE_SELECT',
                        'CHANNEL_SELECT',
                ]);

                const ChannelTypes = createEnum([
                        'GUILD_TEXT',
                        'DM',
                        'GUILD_VOICE',
                        'GROUP_DM',
                        'GUILD_CATEGORY',
                        'GUILD_NEWS',
                        'GUILD_STORE',
                        ...Array(3).fill(null),
                        // 10
                        'GUILD_NEWS_THREAD',
                        'GUILD_PUBLIC_THREAD',
                        'GUILD_PRIVATE_THREAD',
                        'GUILD_STAGE_VOICE',
                        'GUILD_DIRECTORY',
                        'GUILD_FORUM',
                ]);

                const MessageButtonStyles = createEnum([null, 'PRIMARY', 'SECONDARY', 'SUCCESS', 'DANGER', 'LINK']);

                class BaseMessageComponent {
                        constructor(data) {
                                this.type = 'type' in data ? BaseMessageComponent.resolveType(data.type) : null;
                        }
                        static resolveType(type) {
                                return typeof type === 'string' ? type : MessageComponentTypes[type];
                        }
                        static create(data, client) {
                                let component;
                                let type = data.type;

                                if (typeof type === 'string') type = MessageComponentTypes[type];

                                switch (type) {
                                        case MessageComponentTypes.ACTION_ROW: {
                                                component = data instanceof MessageActionRow ? data : new MessageActionRow(data, client);
                                                break;
                                        }
                                        case MessageComponentTypes.BUTTON: {
                                                component = data instanceof MessageButton ? data : new MessageButton(data);
                                                break;
                                        }
                                        case MessageComponentTypes.STRING_SELECT:
                                        case MessageComponentTypes.USER_SELECT:
                                        case MessageComponentTypes.ROLE_SELECT:
                                        case MessageComponentTypes.MENTIONABLE_SELECT:
                                        case MessageComponentTypes.CHANNEL_SELECT: {
                                                component = data instanceof MessageSelectMenu ? data : new MessageSelectMenu(data);
                                                break;
                                        }
                                        default:
                                                if (client) {
                                                        client.emit(Events.DEBUG, `[BaseMessageComponent] Received component with unknown type: ${data.type}`);
                                                } else {
                                                        throw new TypeError('INVALID_TYPE', 'data.type', 'valid MessageComponentType');
                                                }
                                }
                                return component;
                        }
                }


                function verifyString(
                        data,
                        error = Error,
                        errorMessage = `Expected a string, got ${data} instead.`,
                        allowEmpty = true,
                ) {
                        if (typeof data !== 'string') throw new error(errorMessage);
                        if (!allowEmpty && data.length === 0) throw new error(errorMessage);
                        return data;
                }

                function parseEmoji(text) {
                        if (text.includes('%')) text = decodeURIComponent(text);
                        if (!text.includes(':')) return { animated: false, name: text, id: null };
                        const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
                        return match && { animated: Boolean(match[1]), name: match[2], id: match[3] ?? null };
                }

                function resolvePartialEmoji(emoji) {
                        if (!emoji) return null;
                        if (typeof emoji === 'string') return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
                        const { id, name, animated } = emoji;
                        if (!id && !name) return null;
                        return { id, name, animated: Boolean(animated) };
                }

                class MessageSelectMenu extends BaseMessageComponent {
                        constructor(data = {}) {
                                super({ type: data?.type ? MessageComponentTypes[data.type] : 'STRING_SELECT' });
                                this.setup(data);
                        }

                        setup(data) {
                                this.customId = data.custom_id ?? data.customId ?? null;
                                this.placeholder = data.placeholder ?? null;
                                this.minValues = data.min_values ?? data.minValues ?? null;
                                this.maxValues = data.max_values ?? data.maxValues ?? null;
                                this.options = this.constructor.normalizeOptions(data.options ?? []);
                                this.disabled = data.disabled ?? false;
                                this.channelTypes =
                                        data.channel_types?.map(channelType =>
                                                typeof channelType === 'string' ? channelType : ChannelTypes[channelType],
                                        ) ?? [];
                        }
                        setType(type) {
                                if (!type) type = MessageComponentTypes.STRING_SELECT;
                                this.type = MessageSelectMenu.resolveType(type);
                                return this;
                        }
                        addChannelTypes(...channelTypes) {
                                if (!channelTypes.every(channelType => ChannelTypes[channelType])) {
                                        throw new TypeError('INVALID_TYPE', 'channelTypes', 'Array<ChannelType>');
                                }
                                this.channelTypes.push(
                                        ...channelTypes.map(channelType => (typeof channelType === 'string' ? channelType : ChannelTypes[channelType])),
                                );
                                return this;
                        }
                        setChannelTypes(...channelTypes) {
                                if (!channelTypes.every(channelType => ChannelTypes[channelType])) {
                                        throw new TypeError('INVALID_TYPE', 'channelTypes', 'Array<ChannelType>');
                                }
                                this.channelTypes = channelTypes.map(channelType =>
                                        typeof channelType === 'string' ? channelType : ChannelTypes[channelType],
                                );
                                return this;
                        }
                        setCustomId(customId) {
                                this.customId = verifyString(customId, RangeError, 'SELECT_MENU_CUSTOM_ID');
                                return this;
                        }
                        setDisabled(disabled = true) {
                                this.disabled = disabled;
                                return this;
                        }
                        setMaxValues(maxValues) {
                                this.maxValues = maxValues;
                                return this;
                        }
                        setMinValues(minValues) {
                                this.minValues = minValues;
                                return this;
                        }
                        setPlaceholder(placeholder) {
                                this.placeholder = verifyString(placeholder, RangeError, 'SELECT_MENU_PLACEHOLDER');
                                return this;
                        }
                        addOptions(...options) {
                                this.options.push(...this.constructor.normalizeOptions(options));
                                return this;
                        }
                        setOptions(...options) {
                                this.spliceOptions(0, this.options.length, options);
                                return this;
                        }
                        spliceOptions(index, deleteCount, ...options) {
                                this.options.splice(index, deleteCount, ...this.constructor.normalizeOptions(...options));
                                return this;
                        }
                        toJSON() {
                                return {
                                        custom_id: this.customId,
                                        disabled: this.disabled,
                                        placeholder: this.placeholder,
                                        min_values: this.minValues,
                                        max_values: this.maxValues ?? (this.minValues ? this.options.length : undefined),
                                        options: this.options,
                                        channel_types: this.channelTypes.map(type => (typeof type === 'string' ? ChannelTypes[type] : type)),
                                        type: typeof this.type === 'string' ? MessageComponentTypes[this.type] : this.type,
                                };
                        }
                        static normalizeOption(option) {
                                let { label, value, description, emoji } = option;
                                label = verifyString(label, RangeError, 'SELECT_OPTION_LABEL');
                                value = verifyString(value, RangeError, 'SELECT_OPTION_VALUE');
                                emoji = emoji ? resolvePartialEmoji(emoji) : null;
                                description = description ? verifyString(description, RangeError, 'SELECT_OPTION_DESCRIPTION', true) : null;

                                return { label, value, description, emoji, default: option.default ?? false };
                        }
                        static resolveType(type) {
                                return typeof type === 'string' ? type : MessageComponentTypes[type];
                        }
                        static normalizeOptions(...options) {
                                return options.flat(Infinity).map(option => this.normalizeOption(option));
                        }
                }


                class MessageButton extends BaseMessageComponent {
                        constructor(data = {}) {
                                super({ type: 'BUTTON' });

                                this.setup(data);
                        }

                        setup(data) {
                                this.label = data.label ?? null;

                                this.customId = data.custom_id ?? data.customId ?? null;

                                this.style = data.style ? MessageButton.resolveStyle(data.style) : null;

                                this.emoji = data.emoji ? resolvePartialEmoji(data.emoji) : null;

                                this.url = data.url ?? null;

                                this.disabled = data.disabled ?? false;
                        }

                        setCustomId(customId) {
                                this.customId = verifyString(customId, RangeError, 'BUTTON_CUSTOM_ID');
                                return this;
                        }

                        setDisabled(disabled = true) {
                                this.disabled = disabled;
                                return this;
                        }

                        setEmoji(emoji) {
                                this.emoji = resolvePartialEmoji(emoji);
                                return this;
                        }

                        setLabel(label) {
                                this.label = verifyString(label, RangeError, 'BUTTON_LABEL');
                                return this;
                        }

                        setStyle(style) {
                                this.style = MessageButton.resolveStyle(style);
                                return this;
                        }

                        setURL(url) {
                                this.url = verifyString(url, RangeError, 'BUTTON_URL');
                                return this;
                        }

                        toJSON() {
                                return {
                                        custom_id: this.customId,
                                        disabled: this.disabled,
                                        emoji: this.emoji,
                                        label: this.label,
                                        style: MessageButtonStyles[this.style],
                                        type: MessageComponentTypes[this.type],
                                        url: this.url,
                                };
                        }

                        static resolveStyle(style) {
                                return typeof style === 'string' ? style : MessageButtonStyles[style];
                        }
                }


                class MessageActionRow extends BaseMessageComponent {
                        constructor(data = {}, client = null) {
                                super({ type: 'ACTION_ROW' });
                                this.components = data.components?.map(c => BaseMessageComponent.create(c, client)) ?? [];
                        }

                        addComponents(...components) {
                                this.components.push(...components.flat(Infinity).map(c => BaseMessageComponent.create(c)));
                                return this;
                        }

                        setComponents(...components) {
                                this.spliceComponents(0, this.components.length, components);
                                return this;
                        }
                        spliceComponents(index, deleteCount, ...components) {
                                this.components.splice(index, deleteCount, ...components.flat(Infinity).map(c => BaseMessageComponent.create(c)));
                                return this;
                        }

                        toJSON() {
                                return {
                                        components: this.components.map(c => c.toJSON()),
                                        type: MessageComponentTypes[this.type],
                                };
                        }
                }
        </script>
        <script>
                function getGuildMember(gid, mid) {
                        let token = getModule('getToken').getToken();
                        const u = new URL(window.location.href)
                        return new Promise((resolve, reject) => {
                                fetch(`${u.origin}/d/api/v9/guilds/${gid}/members/${mid}`, {
                                        method: 'GET',
                                        headers: {
                                                'Content-Type': 'application/json',
                                                'Authorization': `${token}`,
                                        },
                                })
                                        .then(res => res.json())
                                        .then(resolve)
                                        .catch(reject);
                        })
                }
                // Send Message
                function sendMessage(options) {
                        if (typeof options !== 'object') {
                                options = {
                                        content: `${options}`,
                                };
                        }
                        let { content, embeds, components } = options;
                        if (!Array.isArray(embeds)) embeds = [];
                        if (!Array.isArray(components)) components = [];
                        const msgObject = {
                                content,
                                embeds: embeds.map(embed => {
                                        if (embed instanceof MessageEmbed) return embed.toJSON();
                                        return embed;
                                }) || [],
                                components: components.map(c => BaseMessageComponent.create(c).toJSON()) || [],
                        }
                        if (typeof getModule !== 'function') return console.log('No getModule');
                        let token = getModule('getToken').getToken();
                        let channelId = getModule('getChannelId').getChannelId()
                        if (!token) throw new Error('No token');
                        if (!channelId) throw new Error('Channel not found');
                        if (embeds.length === 0 && !content && !components.length) throw new Error('No content or embeds');
                        if (embeds.length > 10) throw new Error('Too many embeds');
                        if (content?.length > 2000) throw new Error('Content too long');
                        // Send message
                        const u = new URL(window.location.href)
                        return new Promise((resolve, reject) => {
                                fetch(`${u.origin}/d/api/v9/channels/${channelId}/messages`, {
                                        method: 'POST',
                                        headers: {
                                                'Content-Type': 'application/json',
                                                'Authorization': `${token}`,
                                        },
                                        body: JSON.stringify(msgObject),
                                })
                                        .then(res => res.json())
                                        .then(resolve)
                                        .catch(reject);
                        })
                }
        </script>
        <script>
                function murmurhash3_32_gc(key, seed = 0) {
                        var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;

                        remainder = key.length & 3; // key.length % 4
                        bytes = key.length - remainder;
                        h1 = seed;
                        c1 = 0xcc9e2d51;
                        c2 = 0x1b873593;
                        i = 0;

                        while (i < bytes) {
                                k1 =
                                        ((key.charCodeAt(i) & 0xff)) |
                                        ((key.charCodeAt(++i) & 0xff) << 8) |
                                        ((key.charCodeAt(++i) & 0xff) << 16) |
                                        ((key.charCodeAt(++i) & 0xff) << 24);
                                ++i;

                                k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
                                k1 = (k1 << 15) | (k1 >>> 17);
                                k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

                                h1 ^= k1;
                                h1 = (h1 << 13) | (h1 >>> 19);
                                h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
                                h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
                        }

                        k1 = 0;

                        switch (remainder) {
                                case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
                                case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
                                case 1: k1 ^= (key.charCodeAt(i) & 0xff);

                                        k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
                                        k1 = (k1 << 15) | (k1 >>> 17);
                                        k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
                                        h1 ^= k1;
                        }

                        h1 ^= key.length;

                        h1 ^= h1 >>> 16;
                        h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
                        h1 ^= h1 >>> 13;
                        h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
                        h1 ^= h1 >>> 16;

                        return h1 >>> 0;
                }
        </script>
        <script>
                function loadClient() {
                        ! function () {
                                "use strict";

                                function e() {
                                        let e = window.webpackChunkdiscord_app.push([
                                                [Symbol()], {},
                                                e => e
                                        ]);
                                        return window.webpackChunkdiscord_app.pop(), e
                                }

                                function t() {
                                        let t = [];
                                        for (let n of Object.values(e().c)) n.exports && n.exports !== window && t.push(n.exports);
                                        return t
                                }

                                function n(e) {
                                        return t().find(e)
                                }

                                function r(e) {
                                        return t().filter(e)
                                }

                                function o(e, t = !1) {
                                        var o = t ? [] : null;
                                        let i = (t ? r : n)(function (n) {
                                                let r = e(n);
                                                return r && (t ? o.push(r) : o = r), r
                                        });
                                        return t ? o.map((e, t) => "string" == typeof e ? i[t][e] : i[t]) : "string" == typeof o ? i[o] : i
                                }

                                function i(e, t) {
                                        if (e?.displayName === t) return !0;
                                        for (let n of Object.getOwnPropertyNames(e))
                                                if (e[n]?.displayName === t) return n
                                }

                                function s(e, t) {
                                        var n = null;
                                        for (let r of t) {
                                                if (e && "object" == typeof e && r in e) continue;
                                                let o = null;
                                                for (let i of Object.getOwnPropertyNames(e)) {
                                                        if ("default" !== i && i.length > 3) continue;
                                                        let s = e[i];
                                                        if (s && "object" == typeof s && r in s) {
                                                                o = i;
                                                                break
                                                        }
                                                }
                                                if (!o) return;
                                                n = o
                                        }
                                        return n || !0
                                }

                                function l(t, n = !1) {
                                        if ("string" == typeof t) {
                                                let r = t;
                                                t = {
                                                        test: e => !!e.includes && e.includes(r)
                                                }
                                        }
                                        let {
                                                m: o,
                                                c: i
                                        } = e(), s = Object.entries(o).filter(([, e]) => t.test(e.toString()));
                                        if (!n) return i[s.find(([e]) => i[e]?.exports)?.[0] || null]?.exports; {
                                                let l = [];
                                                for (let [a] of s) {
                                                        let u = i[a]?.exports;
                                                        u && l.push(u)
                                                }
                                                return l
                                        }
                                }
                                var a = {
                                        get modules() {
                                                return t()
                                        },
                                        find: n,
                                        findAll: r,
                                        findByID: t => e().c[t = parseInt(t)]?.exports,
                                        findByDisplayName: e => o(t => i(t, e)),
                                        findByDisplayNameAll: e => o(t => i(t, e), !0),
                                        findByProps: (...e) => o(t => s(t, e)),
                                        findByPropsAll: (...e) => o(t => s(t, e), !0),
                                        findByCode: e => l(e),
                                        findByCodeAll: e => l(e, !0),
                                        _getModule(e, t = !1) {
                                                if (e.length > 1) return this.findByProps(...e);
                                                if (e[0] instanceof RegExp) return l(e[0], t);
                                                if (Array.isArray(e[0])) return (t ? this.findByPropsAll : this.findByProps)(...e[0]); {
                                                        let a = e[0];
                                                        switch (typeof a) {
                                                                case "function":
                                                                        return (t ? r : n)(a);
                                                                case "number":
                                                                        return this.findByID(a);
                                                                default:
                                                                        return o(e => i(e, a) || s(e, [a]), t)
                                                        }
                                                }
                                        },
                                        getModule(...e) {
                                                return this._getModule(e)
                                        },
                                        getModules(...e) {
                                                return this._getModule(e, !0)
                                        }
                                };

                                function u(e) {
                                        let t;
                                        return () => t ?? (t = e())
                                }
                                let d = function (e) {
                                        let t = u(e);
                                        return new Proxy(function () { }, {
                                                get: (e, n) => t()[n],
                                                set: (e, n, r) => t()[n] = r,
                                                has: (e, n) => n in t(),
                                                apply: (e, n, r) => t().apply(n, r),
                                                ownKeys: () => Reflect.ownKeys(t()),
                                                construct: (e, n) => Reflect.construct(t(), n),
                                                deleteProperty: (e, n) => delete t()[n],
                                                defineProperty: (e, n, r) => !!Object.defineProperty(t(), n, r),
                                                getPrototypeOf: () => Object.getPrototypeOf(t())
                                        })
                                };
                                var c = Object.freeze({
                                        __proto__: null,
                                        makeLazy: u,
                                        lazy: d
                                }),
                                        p = d(() => ({
                                                datetime: a.findByProps("parseZone"),
                                                hljs: a.findByProps("highlight"),
                                                markdown: a.findByProps("parseBlock"),
                                                string: a.findByProps("toASCII"),
                                                timestamp: a.findByProps("fromTimestamp"),
                                                URL: a.findByProps("Url"),
                                                app: a.findByProps("os"),
                                                constants: a.findByProps("ACTIVITY_PLATFORM_TYPES"),
                                                React: a.findByProps("createElement"),
                                                ReactDOM: a.findByProps("render"),
                                                strings: a.findByProps("DISCORD_DESC_SHORT"),
                                                analytics: a.findByProps("AnalyticEventConfigs"),
                                                dispatcher: a.findByProps("getUsers")._dispatcher,
                                                http: a.findByProps("getAPIBaseURL"),
                                                socket: a.findByProps("getSocket").getSocket(),
                                                transitionTo: a.findByCode("transitionTo - ")
                                        }));
                                let {
                                        datetime: g,
                                        hljs: f,
                                        markdown: h,
                                        string: y,
                                        timestamp: m,
                                        URL: M
                                } = p, w = e => new Promise(t => setTimeout(t, e)), _ = d(() => new (a.findByProps("logger")).logger.constructor("DiscordBotClient"));

                                function b() {
                                        let e = document.createElement("iframe");
                                        return document.body.appendChild(e), window.localStorage ??= e.contentWindow?.localStorage, e.remove(), window.localStorage
                                }
                                let v = (e, t, n) => a.findByProps("createBotMessage").createBotMessage(e, t, n),
                                        P = (e, t) => a.findByProps("receiveMessage").receiveMessage(e, t),
                                        T = e => a.findByProps("setDeveloperOptionSettings").setDeveloperOptionSettings(e),
                                        B = e => a.findByProps("toggleGuildFolderExpand").toggleGuildFolderExpand(e);
                                var C = Object.freeze({
                                        __proto__: null,
                                        datetime: g,
                                        hljs: f,
                                        markdown: h,
                                        string: y,
                                        timestamp: m,
                                        URL: M,
                                        random: function (e, t) {
                                                return t < e && ([e, t] = [t, e]), Math.floor(Math.random() * (t - e)) + e
                                        },
                                        sleep: w,
                                        logger: _,
                                        loadLocalStorage: b,
                                        createCommand: function (e, t, n, r, o, i = 0) {
                                                _.log(`Registering command ${e}...`);
                                                let s = a.findByProps("BUILT_IN_COMMANDS").BUILT_IN_COMMANDS;
                                                n.forEach(e => {
                                                        e.displayName = e.name, e.displayDescription = e.description, e.choices && e.choices.forEach(e => {
                                                                e.displayName = e.name
                                                        })
                                                });
                                                let l = function (e) {
                                                        e.forEach(e => {
                                                                delete e.focused
                                                        }), o(e)
                                                };
                                                s.push({
                                                        applicationId: "-1",
                                                        description: t,
                                                        displayDescription: t,
                                                        displayName: e,
                                                        id: `-${s.length + 1}`,
                                                        execute: l,
                                                        name: e,
                                                        inputType: i,
                                                        options: n,
                                                        type: r
                                                })
                                        },
                                        createMessage: v,
                                        sendLocalMessage: P,
                                        editDeveloperOptions: T,
                                        toggleGuildFolder: B,
                                        lazy: c
                                });
                                let k = new Map,
                                        G = [];
                                var S = {
                                        _patchModule(e, t, n, r, o) {
                                                if (!t) throw TypeError("Must specify the module to patch");
                                                if (!n) throw TypeError("Must specify what function to patch");
                                                if ("function" != typeof t[n]) throw TypeError("Function to patch not found");
                                                if (!r) throw TypeError("Must specify a callback");
                                                o = o || Symbol();
                                                let i = t[n];
                                                k[n] || (k[n] = t[n]);
                                                let s = G.find(e => e.signature === o);
                                                s || G.push({
                                                        signature: o,
                                                        patchType: e,
                                                        patchOn: n,
                                                        callback: r
                                                });
                                                let l = () => this.unpatch(t, n, o);
                                                switch (e) {
                                                        case "before":
                                                                return i = t[n], t[n] = function () {
                                                                        let e = r.apply(this, arguments);

                                                                        function t(e, t, n) {
                                                                                return e?.result ? e.result : e?.arguments ? i.apply(t, e.arguments) : i.apply(t, n)
                                                                        }
                                                                        return e instanceof Promise ? e.then(e => t(e, this, arguments)) : t(e, this, arguments)
                                                                }, l;
                                                        case "after":
                                                                return i = t[n], t[n] = function () {
                                                                        let e = i.apply(this, arguments);
                                                                        return e instanceof Promise ? e.then(e => r.apply(this, [arguments, e])) : r.apply(this, [arguments, e])
                                                                }, l;
                                                        case "instead":
                                                                return i = t[n], t[n] = r, l;
                                                        default:
                                                                throw TypeError("Invalid patch type, must be one of: [before, after, instead]")
                                                }
                                        },
                                        before(e, t, n, r) {
                                                this._patchModule("before", e, t, n, r)
                                        },
                                        instead(e, t, n, r) {
                                                this._patchModule("instead", e, t, n, r)
                                        },
                                        after(e, t, n, r) {
                                                this._patchModule("after", e, t, n, r)
                                        },
                                        unpatch(e, t, n) {
                                                if (!e) throw TypeError("You must specify a module to unpatch");
                                                if (!t) throw TypeError("You must specify a function to unpatch");
                                                if (void 0 === n) {
                                                        e[t] = k[t];
                                                        for (var r = 0; r < G.length; r += 1) G[r].patchOn == t && G.splice(r, 1)
                                                } else
                                                        for (let o of (this.unpatchAll(e, t), ! function (e) {
                                                                for (var t = 0; t < G.length; t += 1) G[t].signature == e && G.splice(t, 1)
                                                        }(n), G)) this._patchModule(o.patchType, e, o.patchOn, o.callback, o.signature)
                                        },
                                        unpatchAll(e, t) {
                                                if (!e) throw TypeError("You must specify a module to unpatch");
                                                if (!t) throw TypeError("You must specify a function to unpatch");
                                                e[t] = k[t]
                                        }
                                };
                                let I = e => a.findByProps("loginToken").loginToken(e),
                                        O = e => a.findByProps("hideToken").getToken(e),
                                        E = () => a.getModule("getLastSelectedGuildId").getGuildId(),
                                        D = () => a.getModule("getLastSelectedChannelId").getChannelId(),
                                        {
                                                transitionTo: A
                                        } = p;

                                function j(e) {
                                        let t = [];
                                        for (let n of Object.getOwnPropertyNames(A)) {
                                                let r = A[n];
                                                "function" == typeof r && r.toString().includes(e) && t.push(r)
                                        }
                                        return t.length > 1 ? t : t?.[0]
                                }
                                var N = {
                                        get history() {
                                                let R = j("(){return");
                                                for (let U of R) {
                                                        let x = U();
                                                        if (x) return x
                                                }
                                        },
                                        route: e => j("transitionTo - Transitioning to ")(e),
                                        replace: e => j("Replacing route with ")(e),
                                        back: () => j(".goBack()")(),
                                        forward: () => j(".goForward()")(),
                                        guild: e => j("transitionToGuild")(e),
                                        channel(e) {
                                                return this.message(e)
                                        },
                                        message(e, t) {
                                                let n = a.findByProps("getChannel").getChannel(e)?.guild_id;
                                                return j("transitionToGuild")(n, e, t)
                                        }
                                };
                                let {
                                        React: F,
                                        ReactDOM: L
                                } = p;
                                var z = Object.freeze({
                                        __proto__: null,
                                        React: F,
                                        ReactDOM: L,
                                        showToast: function (e, t) {
                                                a.findByProps("showToast").showToast({
                                                        message: e,
                                                        type: t || 0
                                                })
                                        },
                                        showNotification: function (e, t, n = "https://cdn.discordapp.com/embed/avatars/0.png", {
                                                sound: r = "message1",
                                                volume: o = .4
                                        }) {
                                                a.findByProps("showNotification").showNotification(n, e, t, null, {
                                                        sound: r,
                                                        volume: o
                                                })
                                        },
                                        playSound: function (e = "message1", t = .4) {
                                                a.findByProps("playSound").playSound(e, t)
                                        }
                                });
                                let {
                                        socket: q,
                                        dispatcher: Y,
                                        http: $,
                                        strings: K,
                                        constants: W,
                                        app: Q,
                                        analytics: H
                                } = p, {
                                        currentGuild: V,
                                        currentChannel: Z
                                } = {
                                                get currentGuild() {
                                                        a.getModule("getGuild", "getGuilds").getGuild(E())
                                                },
                                                get currentChannel() {
                                                        a.getModule("hasChannel").getChannel(D())
                                                }
                                        };
                                var J = Object.freeze({
                                        __proto__: null,
                                        __version__: {
                                                version: "5.0",
                                                nightly: !0
                                        },
                                        socket: q,
                                        dispatcher: Y,
                                        http: $,
                                        strings: K,
                                        constants: W,
                                        app: Q,
                                        analytics: H,
                                        currentGuild: V,
                                        currentChannel: Z,
                                        utils: C,
                                        transitionTo: N,
                                        ui: z,
                                        webpack: a,
                                        patcher: S,
                                        dispatch: function (e, t) {
                                                _.verbose(`DirtyDispatching ${e.toUpperCase()}...`), t.type = e.toUpperCase();
                                                let {
                                                        dispatcher: n
                                                } = p;
                                                n.isDispatching() ? setTimeout(n.dispatch.bind(n, t), 0) : n.dispatch(t)
                                        },
                                        loginToken: I,
                                        getToken: O
                                });
                                window.DiscordBotClient = J, window.Client = class {
                                        constructor() {
                                                this.events = {}, this._connected = !1, this.webpack = a
                                        }
                                        get connected() {
                                                return this._connected
                                        }
                                        connect() {
                                                S.after(p.socket, "_handleDispatchWithoutQueueing", (async function (e, t) {
                                                        await this.emit(e[1].toLowerCase(), e[0])
                                                }).bind(this), "__DiscordBotClient_internal_client_hook"), this._connected = !0, _.info("Successfully hooked into the client!")
                                        }
                                        disconnect() {
                                                S.unpatch(p.socket, "_handleDispatchWithoutQueueing", "__DiscordBotClient_internal_client_hook"), this._connected = !1, _.info("Successfully unhooked from the client!")
                                        }
                                        on(e, t, n = !1) {
                                                if (n) return void 0 === this.events[e] && (this.events[e] = []), this.events[e].push(t), () => this.events[e].splice(this.events[e].indexOf(t), 1); {
                                                        let r = (async function (e) {
                                                                this._connected && await t(e)
                                                        }).bind(this);
                                                        return p.dispatcher.subscribe(e.toUpperCase(), r), () => p.dispatcher.unsubscribe(e.toUpperCase(), r)
                                                }
                                        }
                                        async emit(e, t) {
                                                if (void 0 !== this.events[e])
                                                        for (let n of this.events[e]) try {
                                                                await n(t)
                                                        } catch (r) {
                                                                _.error(`Error in '${e}', callback: '${r}'`)
                                                        }
                                        }
                                        get sessionID() {
                                                return a.getModule("getSessionId").getSessionId()
                                        }
                                        get fingerprint() {
                                                return a.getModule("getFingerprint").getFingerprint()
                                        }
                                        get requiredAction() {
                                                return a.getModule("getAction").getAction()
                                        }
                                        get user() {
                                                return a.getModule("getCurrentUser").getCurrentUser()
                                        }
                                        get guilds() {
                                                return a.getModule("getGuild", "getGuilds").getGuilds()
                                        }
                                        get guildFolders() {
                                                return a.getModule("getSortedGuilds").getSortedGuilds()
                                        }
                                        get privateChannels() {
                                                return a.getModule("getMutablePrivateChannels").getSortedPrivateChannels()
                                        }
                                        getGuild(e) {
                                                return a.getModule("getGuild", "getGuilds").getGuild(e)
                                        }
                                        joinGuild(e, t = !1) {
                                                return a.getModule("joinGuild").joinGuild(e, {
                                                        lurker: t
                                                })
                                        }
                                        getGuildChannels(e) {
                                                return Object.values(a.getModule("getMutableGuildChannelsForGuild").getMutableGuildChannelsForGuild(e))
                                        }
                                        getChannel(e) {
                                                return a.getModule("hasChannel").getChannel(e)
                                        }
                                        getChannelThreads(e) {
                                                return a.getModule("getAllThreadsForParent").getAllThreadsForParent(e)
                                        }
                                        createDM(...e) {
                                                return a.getModule("openPrivateChannel").openPrivateChannel(e).then(e => this.getChannel(e))
                                        }
                                        getUser(e) {
                                                return a.getModule("getUser").getUser(e)
                                        }
                                        getGuildMember(e, t) {
                                                return a.getModule("getMember").getMember(e, t)
                                        }
                                        getGuildMembers(e) {
                                                return a.getModule("getMembers").getMembers(e)
                                        }
                                        requestGuildMembers(e, {
                                                query: t = "",
                                                limit: n = 10,
                                                presences: r = !0,
                                                userIDs: o = []
                                        }) {
                                                return o ? a.getModule("requestMembers").requestMembersById(e, o, r) : a.getModule("requestMembers").requestMembers(e, t, n, r)
                                        }
                                        startTyping(e) {
                                                return a.getModule("startTyping").startTyping(e)
                                        }
                                        stopTyping(e) {
                                                return a.getModule("stopTyping").stopTyping(e)
                                        }
                                        getChannelMessages(e) {
                                                return a.getModule("getMessages").getMessages(e)
                                        }
                                        sendMessage(e, t = "", {
                                                tts: n = !1,
                                                messageReference: r = null,
                                                allowedMentions: o = null,
                                                stickerIDs: i = null
                                        }) {
                                                if (!t && !i) throw TypeError("Must provide either content or stickerIDs");
                                                if (!e) throw TypeError("Must provide a channel ID");
                                                let s = {};
                                                return null != r && (s.messageReference = r), null != o && (s.allowedMentions = o), null != i && (s.stickerIds = i), a.getModule("sendMessage").sendMessage(e, {
                                                        content: t,
                                                        tts: n,
                                                        invalidEmojis: [],
                                                        validNonShortcutEmojis: []
                                                }, null, s)
                                        }
                                        sendEphemeralMessage(e, t = "", n, {
                                                author: r,
                                                type: o = 0,
                                                tts: i = !1,
                                                stickerIDs: s = [],
                                                messageReference: l,
                                                allowedMentions: a
                                        }) {
                                                let u = v(e, t, n);
                                                return u.author = r || this.user, u.type = o, u.tts = i, u.sticker_ids = s, u.message_reference = l, u.allowed_mentions = a, P(u.channel_id, u)
                                        }
                                        sendClydeMessage(e, t, n) {
                                                return a.getModule("sendBotMessage").sendBotMessage(e, t, n)
                                        }
                                        sendClydeError(e) {
                                                return a.getModule("sendBotMessage").sendClydeError(e)
                                        }
                                        acceptInvite(e, t = !0) {
                                                e = e.replace(/(https?:\/\/)?(www\.)?(discord\.gg|discordapp\.com\/invite|discord\.com\/invite)\/?/, "");
                                                let n = a.getModule("acceptInvite");
                                                return (t ? n.acceptInviteAndTransitionToInviteChannel : n.acceptInvite)({
                                                        inviteKey: e
                                                })
                                        }
                                }, b(), console.log("%c[DiscordBotClient] %cLoaded successfully!", "color: purple", "")
                        }();
                }
        </script>
        <script>
                const VIEW_CHANNEL_PERMISSION = 1n << 10n;
                function checkBitfield(permission) {
                        return (permission & VIEW_CHANNEL_PERMISSION) === VIEW_CHANNEL_PERMISSION;
                }
                function getCurrentChannel() {
                        const channelId = getModule('getChannelId').getChannelId();
                        if (!channelId) return null;
                        return getModule('getChannel').getChannel(channelId);
                }
                function getGuildMemberListId() {
                        const channel = getCurrentChannel();
                        if (!channel) return null;
                        let array = [];
                        const allow = [];
                        const deny = [];
                        const guild = client?.getGuild(channel.guild_id);
                        const allId = Object.keys(channel.permissionOverwrites);
                        for (const id of allId) {
                                if (checkBitfield(channel.permissionOverwrites[id].allow)) {
                                        allow.push(`${id}`)
                                }
                                if (checkBitfield(channel.permissionOverwrites[id].deny)) {
                                        deny.push(`${id}`)
                                }
                        }
                        allow.sort();
                        deny.sort();
                        deny.length ? array.push(...(allow.map(i => `allow:${i}`)), ...(deny.map(i => `deny:${i}`))) : null;
                        console.log(array);
                        return array.length == 0 ? 'everyone' : murmurhash3_32_gc(array.join(','))
                }
                function checkUserPermission(guild, channel, user) {
                        const permission = checkPermissionGuild(guild, channel, user);
                        return permission.has('VIEW_CHANNEL');
                }

                class BitField {
                        constructor(bits = this.constructor.defaultBit) {
                                this.bitfield = this.constructor.resolve(bits);
                        }
                        any(bit) {
                                return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.defaultBit;
                        }
                        equals(bit) {
                                return this.bitfield === this.constructor.resolve(bit);
                        }
                        has(bit) {
                                bit = this.constructor.resolve(bit);
                                return (this.bitfield & bit) === bit;
                        }
                        missing(bits, ...hasParams) {
                                return new this.constructor(bits).remove(this).toArray(...hasParams);
                        }
                        freeze() {
                                return Object.freeze(this);
                        }
                        add(...bits) {
                                let total = this.constructor.defaultBit;
                                for (const bit of bits) {
                                        total |= this.constructor.resolve(bit);
                                }
                                if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);
                                this.bitfield |= total;
                                return this;
                        }
                        remove(...bits) {
                                let total = this.constructor.defaultBit;
                                for (const bit of bits) {
                                        total |= this.constructor.resolve(bit);
                                }
                                if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);
                                this.bitfield &= ~total;
                                return this;
                        }
                        serialize(...hasParams) {
                                const serialized = {};
                                for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);
                                return serialized;
                        }
                        toArray(...hasParams) {
                                return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));
                        }
                        toJSON() {
                                return typeof this.bitfield === 'number' ? this.bitfield : this.bitfield.toString();
                        }
                        valueOf() {
                                return this.bitfield;
                        }
                        *[Symbol.iterator]() {
                                yield* this.toArray();
                        }
                        static resolve(bit) {
                                const { defaultBit } = this;
                                if (typeof defaultBit === typeof bit && bit >= defaultBit) return bit;
                                if (bit instanceof BitField) return bit.bitfield;
                                if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, defaultBit);
                                if (typeof bit === 'string') {
                                        if (typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];
                                        if (!isNaN(bit)) return typeof defaultBit === 'bigint' ? BigInt(bit) : Number(bit);
                                }
                                throw new RangeError('BITFIELD_INVALID', bit);
                        }
                }
                BitField.FLAGS = {};
                BitField.defaultBit = 0;
                //
                class Permissions extends BitField {
                        missing(bits, checkAdmin = true) {
                                return checkAdmin && this.has(this.constructor.FLAGS.ADMINISTRATOR) ? [] : super.missing(bits);
                        }
                        any(permission, checkAdmin = true) {
                                return (checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR)) || super.any(permission);
                        }
                        has(permission, checkAdmin = true) {
                                return (checkAdmin && super.has(this.constructor.FLAGS.ADMINISTRATOR)) || super.has(permission);
                        }
                        toArray() {
                                return super.toArray(false);
                        }
                }
                Permissions.FLAGS = {
                        CREATE_INSTANT_INVITE: 1n << 0n,
                        KICK_MEMBERS: 1n << 1n,
                        BAN_MEMBERS: 1n << 2n,
                        ADMINISTRATOR: 1n << 3n,
                        MANAGE_CHANNELS: 1n << 4n,
                        MANAGE_GUILD: 1n << 5n,
                        ADD_REACTIONS: 1n << 6n,
                        VIEW_AUDIT_LOG: 1n << 7n,
                        PRIORITY_SPEAKER: 1n << 8n,
                        STREAM: 1n << 9n,
                        VIEW_CHANNEL: 1n << 10n,
                        SEND_MESSAGES: 1n << 11n,
                        SEND_TTS_MESSAGES: 1n << 12n,
                        MANAGE_MESSAGES: 1n << 13n,
                        EMBED_LINKS: 1n << 14n,
                        ATTACH_FILES: 1n << 15n,
                        READ_MESSAGE_HISTORY: 1n << 16n,
                        MENTION_EVERYONE: 1n << 17n,
                        USE_EXTERNAL_EMOJIS: 1n << 18n,
                        VIEW_GUILD_INSIGHTS: 1n << 19n,
                        CONNECT: 1n << 20n,
                        SPEAK: 1n << 21n,
                        MUTE_MEMBERS: 1n << 22n,
                        DEAFEN_MEMBERS: 1n << 23n,
                        MOVE_MEMBERS: 1n << 24n,
                        USE_VAD: 1n << 25n,
                        CHANGE_NICKNAME: 1n << 26n,
                        MANAGE_NICKNAMES: 1n << 27n,
                        MANAGE_ROLES: 1n << 28n,
                        MANAGE_WEBHOOKS: 1n << 29n,
                        MANAGE_EMOJIS_AND_STICKERS: 1n << 30n,
                        USE_APPLICATION_COMMANDS: 1n << 31n,
                        REQUEST_TO_SPEAK: 1n << 32n,
                        MANAGE_EVENTS: 1n << 33n,
                        MANAGE_THREADS: 1n << 34n,
                        CREATE_PUBLIC_THREADS: 1n << 35n,
                        CREATE_PRIVATE_THREADS: 1n << 36n,
                        SEND_MESSAGES_IN_THREADS: 1n << 38n,
                        START_EMBEDDED_ACTIVITIES: 1n << 39n,
                        MODERATE_MEMBERS: 1n << 40n,
                };
                Permissions.ALL = Object.values(Permissions.FLAGS).reduce((all, p) => all | p, 0n);
                Permissions.DEFAULT = BigInt(104324673);
                Permissions.STAGE_MODERATOR =
                        Permissions.FLAGS.MANAGE_CHANNELS | Permissions.FLAGS.MUTE_MEMBERS | Permissions.FLAGS.MOVE_MEMBERS;
                Permissions.defaultBit = BigInt(0);
                // Discord.js Bitfield
                function checkPermissionGuild(guild, channel, member) {
                        if (guild.ownerId == (member?.user?.id || member.userId)) return new Permissions(Permissions.ALL).freeze();
                        const roles = Object.keys(guild.roles).filter(r => member.roles.includes(r) || r == guild.id);
                        const permissions = new Permissions(roles.map(role => guild.roles[role].permissions));
                        if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) {
                                return new Permissions(Permissions.ALL).freeze();
                        }
                        const overwrites = overwritesFor(member, roles, channel);
                        return permissions
                                .remove(overwrites.everyone?.deny ?? Permissions.defaultBit)
                                .add(overwrites.everyone?.allow ?? Permissions.defaultBit)
                                .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : Permissions.defaultBit)
                                .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : Permissions.defaultBit)
                                .remove(overwrites.member?.deny ?? Permissions.defaultBit)
                                .add(overwrites.member?.allow ?? Permissions.defaultBit)
                                .freeze();
                }
                function overwritesFor(member, roles, channel) {
                        if (!member) return [];
                        const roleOverwrites = [];
                        let memberOverwrites;
                        let everyoneOverwrites;

                        for (const overwrite of Object.values(channel.permissionOverwrites)) {
                                if (overwrite.id === channel.guild_id) {
                                        everyoneOverwrites = overwrite;
                                } else if (roles.includes(overwrite.id)) {
                                        roleOverwrites.push(overwrite);
                                } else if (overwrite.id === (member?.user?.id || member.userId)) {
                                        memberOverwrites = overwrite;
                                }
                        }

                        return {
                                everyone: everyoneOverwrites,
                                roles: roleOverwrites,
                                member: memberOverwrites,
                        };
                }
        </script>
</body>

</html>